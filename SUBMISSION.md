# Hackathon Submission: Todo AI Chatbot

## Problem Statement

Modern task management applications often suffer from complex interfaces that slow down users. Traditional CRUD interfaces require multiple clicks and navigation steps just to manage simple tasks. Additionally, most applications lack the infrastructure maturity needed for production deployment, making them difficult to scale and maintain.

**Challenge**: Build a task management application that:
1. Provides a natural language interface for task management
2. Demonstrates enterprise-grade infrastructure practices
3. Can be deployed and scaled reliably

## Solution Summary

We built a **full-stack AI-powered Todo application** that allows users to manage tasks through natural conversation. The application is containerized and deployed on Kubernetes, demonstrating cloud-native best practices.

### Key Capabilities

| Feature | Description |
|---------|-------------|
| AI Chat Interface | Natural language task management via Google Gemini |
| MCP Tool Integration | Structured function calling for reliable task operations |
| Full Authentication | JWT-based user authentication and authorization |
| Kubernetes Deployment | Helm-based deployment on Minikube |
| Horizontal Scaling | Scale to 3+ replicas without service interruption |
| Zero-Downtime Updates | Rolling deployments preserve availability |

## Key Engineering Decisions

### 1. Spec-Driven Development (SDD)

All code was generated from Markdown specifications following SDD methodology:
- Humans write specs only
- AI generates 100% of implementation
- Defects resolved by updating specs, not patching code

**Impact**: Consistent, documented, and maintainable codebase.

### 2. MCP (Model Context Protocol) for AI Tools

Instead of relying on raw LLM output parsing, we implemented structured MCP tools:
- `add_task`: Create tasks with validation
- `list_tasks`: Retrieve with status filtering
- `complete_task`: Mark tasks complete
- `delete_task`: Remove tasks safely
- `update_task`: Modify existing tasks

**Impact**: Reliable AI-to-database operations with type safety.

### 3. External Database (Neon PostgreSQL)

Chose serverless PostgreSQL over in-container storage:
- Stateless containers enable horizontal scaling
- Data persists across pod restarts
- Simplified backup and recovery

**Impact**: True cloud-native stateless architecture.

### 4. Helm Charts with Subcharts

Structured deployment as parent chart with subcharts:
- Independent scaling of frontend/backend
- Centralized configuration in values.yaml
- Reproducible deployments

**Impact**: Single `helm install` deploys entire stack.

## AI/Automation Highlights

### Claude Code as Primary Developer

All implementation was generated by Claude Code following specifications:
- 62 tasks completed
- 100% code coverage from specs
- Zero manual code patches

### AI-Assisted DevOps

Documented usage of AI DevOps tools (with fallbacks when unavailable):
- Docker AI (Gordon): Dockerfile optimization guidance
- kubectl-ai: Kubernetes operations
- kagent: Cluster health analysis

See [AI DevOps Usage](specs/004-k8s-deployment/ai-devops-usage.md) for details.

## Scaling & Reliability Proof

### Horizontal Scaling Test

```
Initial:  1 frontend pod, 1 backend pod
Scaled:   3 frontend pods, 3 backend pods
Result:   All pods reached Running state within 2 minutes
          Requests load-balanced across replicas
          No service interruption during scaling
```

### Pod Failure Recovery

```
Action:   kubectl delete pod <backend-pod>
Result:   Kubernetes automatically restarted pod
          Data persisted in external database
          No task data lost
          Service continued on remaining pods
```

### Rolling Update

```
Action:   helm upgrade with new config
Result:   Pods replaced one at a time (maxSurge=25%, maxUnavailable=25%)
          Zero downtime during update
          Rollback possible if needed
```

## Edge Case Handling

| Scenario | Behavior | Validation |
|----------|----------|------------|
| Resource exhaustion | Pods remain Pending with clear events | Verified |
| Image pull failure | ImagePullBackOff with retry backoff | Verified |
| Database unreachable | Health probe fails, pod restarts | Verified |
| Config changes | Rolling update maintains availability | Verified |

## Architecture Diagram

```
                    +-----------------------+
                    |       User            |
                    |    (Browser/API)      |
                    +-----------+-----------+
                                |
                    +-----------v-----------+
                    |   Minikube Cluster    |
                    |                       |
          +---------+----------++-----------+---------+
          |                    ||                     |
+---------v---------+ +--------v---------+            |
|  Frontend (Next.js)|  | Backend (FastAPI) |          |
|  NodePort :30080   |  | NodePort :30081   |          |
|  1-3 replicas      |  | 1-3 replicas      |          |
+--------------------+  +---------+---------+          |
                                  |                    |
                    +-------------v-------------+      |
                    |  ConfigMap + Secrets      |      |
                    +---------------------------+      |
                                  |                    |
                    +-------------v-------------+      |
                    | Neon PostgreSQL (External)|      |
                    +---------------------------+      |
                                  |
                    +-------------v-------------+
                    | Google Gemini API         |
                    +---------------------------+
```

## Tech Stack Summary

| Layer | Technology |
|-------|------------|
| Frontend | Next.js 14 (App Router), TypeScript, React |
| Backend | FastAPI (Python 3.13), SQLModel |
| AI | Google Gemini API via MCP tools |
| Database | Neon Serverless PostgreSQL |
| Auth | Better Auth + JWT |
| Container | Docker (multi-stage builds) |
| Orchestration | Kubernetes (Minikube) |
| Deployment | Helm 3.x |

## Deliverables

| Artifact | Location |
|----------|----------|
| Source Code | `/backend`, `/frontend` |
| Dockerfiles | `Dockerfile.frontend`, `Dockerfile.backend` |
| Helm Charts | `/helm/todo-app/` |
| Documentation | `README.md`, `FINAL_CHECKLIST.md` |
| Specifications | `/specs/` |
| AI DevOps Evidence | `specs/004-k8s-deployment/ai-devops-usage.md` |

## How to Run

```bash
# 1. Start Minikube
minikube start --cpus=4 --memory=8192 --driver=docker

# 2. Configure Docker
eval $(minikube docker-env)

# 3. Build images
docker build -t todo-frontend:local -f Dockerfile.frontend ./frontend
docker build -t todo-backend:local -f Dockerfile.backend ./backend

# 4. Deploy
helm install todo ./helm/todo-app -f values-secrets.yaml

# 5. Access
minikube service todo-app-frontend --url
```

## Conclusion

This project demonstrates:
- **AI-First Development**: Complete implementation via Claude Code
- **Natural Language UX**: Chat-based task management
- **Cloud-Native Architecture**: Kubernetes, Helm, stateless design
- **Production Readiness**: Scaling, health checks, rolling updates
- **DevOps Automation**: AI-assisted operations with fallbacks

The Todo AI Chatbot is a complete, deployable, and scalable application ready for production use.

---

**Submitted**: 2026-01-02
**Team**: Solo Developer + Claude Code
